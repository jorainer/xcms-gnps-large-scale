---
title: "xcms-based preprocessing of a large LC-MS/MS data set; xcms version 3 with MSnbase infrastructure"
subtitle: "Supplementary Material for: *xcms in peak form: Now anchoring a complete
metabolomics data preprocessing and analysis software ecosystem*"
output: pdf_document
author: "Philippine Louail, Johannes Rainer"
bibliography: references.bib
---

```{r, echo = FALSE, message = FALSE}
library(BiocStyle)
```

# Introduction

In this document we perform the preprocessing of a large untargeted
metabolomics dataset using the `r Biocpkg("xcms")` package [@louail_xcms_2025]
and record memory usage and timing of function calls during the analysis. The
dataset consists of approximately **1,000 samples** (mzXML) files which can be
downloaded from the *MassIVE* repository. The accession ID of the data set is
*MSV000080030*. Preprocessing of this data set was also performed in
[@nothias_feature-based_2020] to exemplify large-scale analysis with *xcms* in
the framework of the GNPS environment. The analysis in this document uses the
same *xcms* functions and classes from that analysis, i.e., relies on *MSnbase*
for MS data handling.

The analysis in this document was defined based on Bioconductor version 3.10
with R version 3.7.3. The versions of the *xcms* and *MSnbase* packages are
listed in the *Session and computation information* section. Running the code
from this file on newer versions of R/Bioconductor, respectively versions of
the *xcms* package will most likely result in errors. The present analysis was
run using the
[*RELEASE_3_10*](https://hub.docker.com/layers/bioconductor/bioconductor_docker/RELEASE_3_10/images/sha256-dbe121d95a31eaa88a493ae66aa4035a236b2e37c69341ae74acb405e126f0c6)
Bioconductor docker image (install with
`docker pull bioconductor/bioconductor_docker:RELEASE_3_10)`).

Note that the settings for the individual preprocessing steps were not
optimized for the present data set. For information on how to derive settings
specific for a data set see the
[Metabonaut](https://doi.org/10.5281/zenodo.15062929) resource
[@louail_rformassspectrometrymetabonaut_2025].

# Data import

It is assumed that the mzXML files were downloaded from MassIVE and the
*MSV000080030* folder was placed within the same directory this quarto document
resides. We first load all required libraries and configure the parallel
processing setup. For the present analysis we use 4 parallel processes. To
track memory usage and duration of the various function calls we use the
`peakRAM()` function from the same-named R package. Note however that this
function fails to properly track memory usage in R if parallel processing is
used.

```{r, message = FALSE}
library(MSnbase)
library(xcms)
library(peakRAM)
```

Setup parallel processing.

```{r}
NCORES <- 4
register(bpstart(MulticoreParam(NCORES)), default = TRUE)
```

We next define all data files of the project, drop measurements of blanks and
import the data as an `OnDiskMSnExp` object.

```{r}
fls <- dir("MSV000080030", pattern = "mzXML$", full.names = TRUE,
           recursive = TRUE)
fls <- fls[-grep(fls, pattern = "/Blank", fixed = TRUE)]
pr <- peakRAM(
    od <- readMSData(fls, mode = "onDisk")
)
```

The size of the object in memory is shown below. Note that only spectra
metadata is loaded into memory, while the mass peak data is retrieved
on-the-fly from the original data files.

```{r}
print(object.size(od), units = "GB")
```

# Chromatographic peak detection

Chromatographic peak detection is performed using the *CentWave* algorithm
using the same seetings as in [@nothias_feature-based_2020].

```{r}
cwp <- CentWaveParam(snthresh = 3, noise = 800, peakwidth = c(2, 30), ppm = 20)
tmp <- peakRAM(
    xod <- findChromPeaks(od, param = cwp)
)
pr <- rbind(pr, tmp)
```

In total `r nrow(chromPeaks(xod))` chromatographic peaks were identified.

Peak refinement is not available with *xcms* version used in this analysis
(3.8.2), thus we have to skip this step.

The size of the result object in memory is:

```{r}
print(object.size(xod), units = "GB")
```

# Alignment

Prior retention time alignment we need to perform an initial correspondence
analysis. Among the such defined features (i.e., chromatographic peaks grouped
across samples) *anchor peaks* will be defined that are used to reduce
retention time shifts and hence align the samples.

```{r}
pdp <- PeakDensityParam(sampleGroups = rep(1, length(fileNames(xod))),
                        bw = 2, binSize = 0.1, minFraction = 0.5)
tmp <- peakRAM(
    xod <- groupChromPeaks(xod, param = pdp)
)
pr <- rbind(pr, tmp)
```

Next we perform the retention time alignment.

```{r}
pgp <- PeakGroupsParam(minFraction = 0.7, extraPeaks = 100, span = 0.3)
tmp <- peakRAM(
    xod <- adjustRtime(xod, param = pgp)
)
pr <- rbind(pr, tmp)
```

The size of the result object in memory is:

```{r}
print(object.size(xod), units = "GB")
```

# Correspondence analysis

We next perform the correspondence analysis.

```{r}
pdp <- PeakDensityParam(sampleGroups = rep(1, length(fileNames(xod))),
                        bw = 2, binSize = 0.015, minFraction = 0.03)
tmp <- peakRAM(
    xod <- groupChromPeaks(xod, param = pdp)
)
pr <- rbind(pr, tmp)
```

After correspondence analysis we have `r nrow(featureDefinitions(xod))`
features.

The size of the result object in memory is:

```{r}
print(object.size(xod), units = "GB")
```

# Gap filling

As a last step in the preprocessing, we perform the gap-filling to reduce the
number of missing values. The only gap-filling method available for the
currently used *xcms* version 3.8.2 is the `FillChromPeaksParam()` method.

```{r}
## Fill missing peak data
medWidth <- median(chromPeaks(xod)[, "rtmax"] -
                   chromPeaks(xod)[, "rtmin"])
tmp <- peakRAM(
    xod <- fillChromPeaks(
        xod, param = FillChromPeaksParam(fixedRt = medWidth))
)
pr <- rbind(pr, tmp)
```

The size of the result object in memory is:

```{r}
print(object.size(xod), units = "GB")
```

# Summary of preprocessing performance

The time elapse for the individual preprocessing steps along with memory usage
is shown in the table below. Note that on parallel processing setups the memory
usage is not tracked properly by the `peakRAM()` function.

```{r, results = "asis"}
library(pander)
pr$Elapsed_Time_sec <- pr$Elapsed_Time_sec / 60
colnames(pr)[colnames(pr) == "Elapsed_Time_sec"] <- "Elapsed_Time_minutes"
pandoc.table(pr, style = "rmarkdown")
```

```{r}
dr <- "xcms-preprocessing-msnbase"
dir.create(dr, showWarnings = FALSE)
save(xod, file = file.path(dr, "xod.RData"))
```

# Prepare and export data for GNPS

We next identify all MS2 spectra for all defined LC-MS features and export
these, along with the feature abundances for use in the GNPS environment as
described in [@nothias_feature-based_2020].

We first extract the feature values from the result object.

```{r}
fall <- featureDefinitions(xod)[, c("mzmin", "mzmed", "mzmax",
                                     "rtmin", "rtmed", "rtmax")]
fall <- cbind(feature_id = rownames(fall),
              fall,
              featureValues(xod, value = "into"))
write.table(fall, file.path(dr, "xcms_all_features.txt"), sep = "\t",
            quote = FALSE, row.names = FALSE)
```

Next we extract all MS2 spectra associated with any of the features' detected
chromatographic peaks. Note that we disable parallel processing for this step,
because we would run out of memory on the computer setup used.

```{r, message = FALSE}
bpstop()
register(SerialParam())
source("https://raw.githubusercontent.com/jorainer/xcms-gnps-tools/master/customFunctions.R")
pr_ms2 <- peakRAM(
    ms2_all <- clean(featureSpectra(xod, return.type = "Spectra"), all = TRUE)
)
```

In total `r length(ms2_all)` MS2 spectra were identified and extracted for the
`r nrow(fall)` LC-MS features.

We next select a single MS2 spectrum for each feature and export this reduced
set also as an .mgf file.

```{r, message = FALSE}
tmp <- peakRAM(
    ## Select for each feature the MS2 spectrum with the largetst TIC
    ms2_maxtic <- combineSpectra(ms2_all, fcol = "feature_id",
                                 fun = maxTic)
)
pr_ms2 <- rbind(pr_ms2, tmp)
```

Next we export the data to a file which can then be submitted to GNPS
[feature-based molecular
networking](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking/).

```{r}
tmp <- peakRAM(
    writeMgfData(ms2_maxtic, file.path(dr, "ms2_maxtic.mgf"))
)
pr_ms2 <- rbind(pr_ms2, tmp)
```

# Summary of data export performance

The time elapse for the individual result extraction, formatting for GNPS and
export steps along with memory usage is shown in the table below.

```{r, results = "asis"}
pr_ms2$Elapsed_Time_sec <- pr_ms2$Elapsed_Time_sec / 60
colnames(pr_ms2)[colnames(pr_ms2) == "Elapsed_Time_sec"] <-
    "Elapsed_Time_minutes"
pandoc.table(pr_ms2, style = "rmarkdown")
```

# Session and computation information

The present analysis was performed using the Bioconductor docker images for the
developmental version 3.22. The analysis was run on `r NCORES` CPUs of a
[Framework](https://frame.work) 13' notebook with a 13th Gen Intel(R) Core(TM)
i7-1370P CPU (20 cores) and 64 GB of main memory.

```{r}
sessionInfo()
```

# References
