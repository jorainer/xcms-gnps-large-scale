---
title: "xcms-based preprocessing of a large LC-MS/MS data set using the old functionality"
format: pdf
author: "Philippine Louail, Johannes Rainer"
bibliography: references.bib
---

# Introduction

In this document we perform the preprocessing of a large untargeted metabolomics
dataset using an old version of the *xcms* package [@louail_xcms_2025] and
record memory usage and timing of function calls during the analysis. The
dataset consists of approximately 1,000 samples (mzXML) files which can be
downloaded from the *MassIVE* repository. The accession ID of the data set is
*MSV000080030*. Preprocessing of this data set was also performed in
[@nothias_feature-based_2020] to exemplify large-scale analysis with *xcms* in
the framework of the GNPS environment. Importantly, the *xcms* package version
used in the present analysis did **not support LC-MS/MS data analysis**, hence,
parts of the workflows are not conducted. Also, other analysis steps, such as
the peak refinement, are skipped or a different, old algorithm had to be used
(such as for gap-filling).

Note that the settings for the individual preprocessing steps were not
optimized for the present data set. For information on how to derive settings
specific for a data set see the
[Metabonaut](https://doi.org/10.5281/zenodo.15062929) resource [@louail_rformassspectrometrymetabonaut_2025].

# Analysis setup

It is assumed that the mzXML files were downloaded from MassIVE and the
*MSV000080030* folder was placed within the same directory this quarto document
resides. We first load all required libraries and configure the parallel
processing setup. For the present analysis we use 4 parallel processes. To track
memory usage and duration of the various function calls we use the `peakRAM()`
function from the same-named R package. Note however that this function fails to
properly track memory usage in R if parallel processing is used.

```{r}
lb <- "/usr/local/lib/R/host-site-library"
install.packages("peakRAM", lib = lb)
install.packages("pander", lib = lb)
library(xcms)
library(pander, lib.loc = lb)
library(peakRAM, lib.loc = lb)
library(BiocParallel)
```

We next define all data files of the project, drop measurements of blanks and
import the data as a `MsExperiment` object.

```{r}
fls <- dir("MSV000080030", pattern = "mzXML$", full.names = TRUE,
           recursive = TRUE)
fls <- fls[-grep(fls, pattern = "/Blank", fixed = TRUE)]
```

```{r}
NCORES <- 4
register(bpstart(MulticoreParam(NCORES)), default = TRUE)
```

# Chromatographic peak detection

Chromatographic peak detection is performed using the *CentWave* algorithm using
the same seetings as in [@nothias_feature-based_2020].

```{r}
pr <- peakRAM(
    xs <- xcmsSet(files = fls, method = "centWave", peakwidth = c(2, 30),
                  ppm = 20, snthresh = 3, noise = 800)
)
```

Peak refinement was not implemented in the used *xcms* package version, so this
step is not performed here.

```{r}
print(object.size(xs), units = "GB")
```

Memory usage is low, because the result object does not contain any reference to
the raw data.

# Alignment

Prior retention time alignment we need to perform an initial correspondence
analysis. Among the such defined features (i.e., chromatographic peaks grouped
across samples) *anchor peaks* will be defined that are used to reduce retention
time shifts and hence align the samples.

```{r, message = FALSE}
sampclass(xs) <- factor(rep(1L, length(fls)))
tmp <- peakRAM(
    xs <- group(xs, method = "density", bw = 2, mzwid = 0.1, minfrac = 0.5)
)
pr <- rbind(pr, tmp)
```

Next we perform the retention time alignment.

```{r}
tmp <- peakRAM(
    xs <- retcor(xs, method = "peakgroups", span = 0.3, extra = 100,
                 missing = ceiling(length(fls) * 0.3))
)
pr <- rbind(pr, tmp)
```

The size of the result object in memory is:

```{r}
print(object.size(xs), units = "GB")
```

# Correspondence analysis

We next perform the correspondence analysis.

```{r, message = FALSE}
tmp <- peakRAM(
    xs <- group(xs, method = "density", bw = 2, mzwid = 0.015, minfrac = 0.5)
)
pr <- rbind(pr, tmp)
```

The size of the result object in memory is:

```{r}
print(object.size(xs), units = "GB")
```

# Gap filling

As a last step in the preprocessing, we perform the gap-filling to reduce the
number of missing values. Note that the gap-filling approach from the original
*xcms* is completely different to the one available in the more recent versions
of the package.

```{r}
tmp <- peakRAM(
    xs <- fillPeaks(xs, method = "chrom", expand.mz = 0.01, expand.rt = 3)
)
pr <- rbind(pr, tmp)
```

The size of the result object in memory is:

```{r}
print(object.size(xs), units = "GB")
```

# Summary of preprocessing performance

The time elapse for the individual preprocessing steps along with memory usage
is shown in the table below. Note that on parallel processing setups the memory
usage is not tracked properly by the `peakRAM()` function.

```{r, results = "asis"}
library(pander)
pr$Elapsed_Time_sec <- pr$Elapsed_Time_sec / 60
colnames(pr)[colnames(pr) == "Elapsed_Time_sec"] <- "Elapsed_Time_minutes"
pandoc.table(pr, style = "rmarkdown")
```

# Prepare and export data for GNPS

This part of the analysis can not be performed since the original *xcms* version
did not support LC-MS/MS data analysis.

# Session and computation information

The present analysis was performed using the Bioconductor docker images for the
developmental version 3.22. The analysis was run on `r NCORES` CPUs of a
[Framework](https://frame.work) 13' notebook with a 13th Gen Intel(R) Core(TM)
i7-1370P CPU (20 cores) and 64 GB of main memory.

```{r}
sessionInfo()
```

# References
