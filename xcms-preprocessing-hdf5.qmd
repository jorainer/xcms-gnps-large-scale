---
title: "xcms-based preprocessing of a large LC-MS/MS data set using on-disk
result storage"
format: pdf
author: "Philippine Louail, Johannes Rainer"
bibliography: references.bib
---

```{r}
#| echo: false
#| message: false
library(BiocStyle)
```

# Introduction

In this document we perform the preprocessing of a large untargeted metabolomics
dataset using the `r Biocpkg("xcms")` package [@louail_xcms_2025] and record
memory usage and timing of function calls during the analysis. In the present
analysis we use the new low-memory data processing introduced in *xcms* version
4.7. Instead of keeping the preprocessing results in memory, they are stored in
a HDF5 file ensuring efficient data access and low memory footprint. The dataset
analyzed in this document consists of approximately 1,000 samples (mzXML) files
which can be downloaded from the *MassIVE* repository. The accession ID of the
data set is *MSV000080030*. Preprocessing of this data set was also performed in
[@nothias_feature-based_2020] to exemplify large-scale analysis with *xcms* in
the framework of the GNPS environment.

Note that the settings for the individual preprocessing steps were not optimized
for the present data set. See
[Metabonaut](https://doi.org/10.5281/zenodo.15062929)
[@louail_rformassspectrometrymetabonaut_2025] for more information on how to
derive data set-specific settings.

# Data import

It is assumed that the mzXML files were downloaded from MassIVE and the
*MSV000080030* folder was placed within the same directory this quarto document
resides. We first load all required libraries and configure the parallel
processing setup. For the present analysis we use 4 parallel processes. To track
memory usage and duration of the various function calls we use the `peakRAM()`
function from the same-named R package. Note however that this function fails to
properly track memory usage in R if parallel processing is used.

```{r}
#| message: false
library(MsExperiment)
library(Spectra)
library(xcms)
library(peakRAM)
```

Setup parallel processing.

```{r}
NCORES <- 4
register(bpstart(MulticoreParam(NCORES)), default = TRUE)
```

We next define all data files of the project, drop measurements of blanks and
import the data as a `MsExperiment` object.

```{r}
fls <- dir("MSV000080030", pattern = "mzXML$", full.names = TRUE,
           recursive = TRUE)
fls <- fls[-grep(fls, pattern = "/Blank", fixed = TRUE)]
pr <- peakRAM(
    mse <- readMsExperiment(fls)
)
```

The data set consists of in total `r length(mse)` files with in total
`r length(spectra(mse))` spectra, `r sum(msLevel(spectra(mse))) == 1L` MS1 and
`r sum(msLevel(spectra(mse))) == 2L` MS2 spectra. The size of the object in
memory is shown below. Note that only spectra metadata is loaded into memory,
while the mass peak data is retrieved on-the-fly from the original data files.

```{r}
print(object.size(mse), units = "GB")
```

# Chromatographic peak detection

Chromatographic peak detection is performed using the *CentWave* algorithm using
the same seetings as in [@nothias_feature-based_2020]. With parameter `hdf5File`
we define the name of the file that is used to store the *xcms* preprocessing
results.

```{r}
cwp <- CentWaveParam(snthresh = 3, noise = 800, peakwidth = c(2, 30),
                     ppm = 20)
tmp <- peakRAM(
    xmse <- findChromPeaks(mse, param = cwp, chunkSize = NCORES,
                           hdf5File = "xmse.h5")
)
pr <- rbind(pr, tmp)
```

In total `r nrow(chromPeaks(xmse))` chromatographic peaks were identified. We
next perform the peak refinement to reduce peak detection artifacts.

```{r}
tmp <- peakRAM(
    xmse <- refineChromPeaks(xmse, MergeNeighboringPeaksParam(),
                             chunkSize = NCORES))
pr <- rbind(pr, tmp)
```

After peak refinement, `r nrow(chromPeaks(xmse))` chromatographic peaks are
present.

The size of the result object in memory is:

```{r}
print(object.size(xmse), units = "GB")
```

# Alignment

Prior retention time alignment we need to perform an initial correspondence
analysis. Among the such defined features (i.e., chromatographic peaks
grouped across samples) *anchor peaks* will be defined that are used to reduce
retention time shifts and hence align the samples.

```{r}
pdp <- PeakDensityParam(sampleGroups = rep(1, length(xmse)),
                        bw = 2, binSize = 0.1, minFraction = 0.5)
tmp <- peakRAM(
    xmse <- groupChromPeaks(xmse, param = pdp)
)
pr <- rbind(pr, tmp)
```

Next we perform the retention time alignment.

```{r}
pgp <- PeakGroupsParam(minFraction = 0.7, extraPeaks = 100, span = 0.3)
tmp <- peakRAM(
    xmse <- adjustRtime(xmse, param = pgp)
)
pr <- rbind(pr, tmp)
```

The size of the result object in memory is:

```{r}
print(object.size(xmse), units = "GB")
```

# Correspondence analysis

We next perform the correspondence analysis.

```{r}
pdp <- PeakDensityParam(sampleGroups = rep(1, length(xmse)),
                        bw = 2, binSize = 0.015, minFraction = 0.03)
tmp <- peakRAM(
    xmse <- groupChromPeaks(xmse, param = pdp)
)
pr <- rbind(pr, tmp)
```

The total number of defined LC-MS features are
`r nrow(featureDefinitions(xmse))`.

The size of the result object in memory is:

```{r}
print(object.size(xmse), units = "GB")
```

# Gap filling

As a last step in the preprocessing, we perform the gap-filling to reduce the
number of missing values.

```{r}
tmp <- peakRAM(
    xmse <- fillChromPeaks(xmse, param = ChromPeakAreaParam(),
                           chunkSize = NCORES)
)
pr <- rbind(pr, tmp)
```

The size of the result object in memory is:

```{r}
print(object.size(xmse), units = "GB")
```

# Summary of preprocessing performance

The time elapse for the individual preprocessing steps along with memory usage
is shown in the table below. Note that on parallel processing setups the memory
usage is not tracked properly by the `peakRAM()` function.

```{r, results = "asis"}
library(pander)
pr$Elapsed_Time_sec <- pr$Elapsed_Time_sec / 60
colnames(pr)[colnames(pr) == "Elapsed_Time_sec"] <- "Elapsed_Time_minutes"
pandoc.table(pr, style = "rmarkdown")
```

```{r}
dr <- "xcms-preprocessing-hdf5"
dir.create(dr, showWarnings = FALSE)
save(xmse, file = file.path(dr, "xmse_h5.RData"))
```

# Prepare and export data for GNPS

We next identify all MS2 spectra for all defined LC-MS features and export
these, along with the feature abundances for use in the GNPS environment as
described in [@nothias_feature-based_2020].

We first extract the feature values from the result object.

```{r}
fall <- featureDefinitions(xmse)[, c("mzmin", "mzmed", "mzmax",
                                     "rtmin", "rtmed", "rtmax")]
fall <- cbind(feature_id = rownames(fall),
              fall,
              featureValues(xmse, value = "into"))
write.table(fall, file.path(dr, "xcms_all_features.txt"), sep = "\t",
            quote = FALSE, row.names = FALSE)
```

Next we extract all MS2 spectra associated with any of the features'
detected chromatographic peaks.

```{r}
#| message: false
source("https://raw.githubusercontent.com/jorainer/xcms-gnps-tools/master/customFunctions.R")
pr_ms2 <- peakRAM(
    ms2_all <- featureSpectra(xmse, skipFilled = TRUE)
)
```

In total `r length(ms2_all)` MS2 spectra were identified and extracted for the
`r nrow(fall)` LC-MS features. We also clean and re-format the extracted MS2
spectra for their use in GNPS.

```{r}
## ms2_all <- filterIntensity(ms2_all, intensity = 0)
## ms2_all <- filterEmptySpectra(ms2_all)
ms2_all <- formatSpectraForGNPS(ms2_all)
```

We next select a single MS2 spectrum for each feature and export this reduced
set also as an .mgf file. We use the `Spectra::combineSpectra()` function to
*combine* spectra with the same value for parameter `f` into one. In the example
below we use the `maxTicPeaksData()` function from the
[xcms-gnps-tools](https://github.com/jorainer/xcms-gnps-tools) repository to
report for each feature only the fragment peaks matrix with the largest TIC. As
an alternative, the `combineSpectra()` method would also allow to create a
*representative* spectrum combining all fragment peaks or reporting fragment
peaks present in e.g. 80% of related fragment spectra (see next section for an
example). The sets of fragment spectra assigned to a feature have to be declared
with parameter `f` (which in our example is set to `f =
feature_ms2$FEATURE_ID`, defining for each spectrum the feature it is
related to). In addition, we have to change parameter `p` (which defines how to
split and process the `Spectra` object in parallel) from the default `p =
dataStorage(object)` to `p = rep(1, length(feature_ms2))` hence switching
from a per-mzML-file-based processing to a processing that allows to select a
single representative fragment spectrum for feature across all data files.

```{r}
#| message: false
tmp <- peakRAM(
    ms2_maxtic <- combineSpectra(
        ms2_all, f = ms2_all$FEATURE_ID,
        p = rep(1, length(ms2_all)), FUN = maxTicPeaksData)
)
pr_ms2 <- rbind(pr_ms2, tmp)
spectraNames(ms2_maxtic) <- paste0(ms2_maxtic$FEATURE_ID, " maxTic")
```

Next we export the data to a file which can then be submitted to GNPS [feature-based
molecular
networking](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking/).

```{r}
library(MsBackendMgf)
tmp <- peakRAM(
    export(backend = MsBackendMgf(),
           ms2_maxtic,
           file = file.path(dr, "ms2spectra_maxTic.mgf"))
)
pr_ms2 <- rbind(pr_ms2, tmp)
```

# Summary of data export perforamce

The time elapse for the individual result extraction, formatting for GNPS and
export steps along with memory usage is shown in the table below.

```{r, results = "asis"}
pr_ms2$Elapsed_Time_sec <- pr_ms2$Elapsed_Time_sec / 60
colnames(pr_ms2)[colnames(pr_ms2) == "Elapsed_Time_sec"] <-
    "Elapsed_Time_minutes"
pandoc.table(pr_ms2, style = "rmarkdown")
```

# Session and computation information

The present analysis was performed using the Bioconductor docker images for the
developmental version 3.22. The analysis was run on `r NCORES` CPUs of a
[Framework](https://frame.work/) 13' notebook with a 13th Gen Intel(R) Core(TM)
i7-1370P CPU (20 cores) and 64 GB of main memory.

```{r}
sessionInfo()
```

# References
